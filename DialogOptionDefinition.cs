using FrooxEngine;
using FrooxEngine.UIX;
using System.Reflection;
using System;
using System.Collections.Generic;
using Elements.Core;

namespace UIXDialogBuilder
{
    /// <summary>
    /// Defines a configuration option in the dialog window
    /// </summary>
    /// <typeparam name="TDialogState">type of the dialog object</typeparam>
    /// <typeparam name="TValue">type of the edited value</typeparam>
    public class DialogOptionDefinition<TDialogState, TValue> : IDialogEntryDefinition<TDialogState> where TDialogState : IDialogState
    {
        private readonly object key;
        private readonly Action<TDialogState, TValue> setter;
        private readonly Func<TDialogState, TValue> getter;
        private readonly ICustomAttributeProvider customAttributes;

        private readonly DialogOptionAttribute conf;

        /// <summary>
        /// Creates a configuration option
        /// </summary>
        /// <param name="key">to identify this element</param>
        /// <param name="setter">putting the value into the dialog state</param>
        /// <param name="getter">getting the current value out of the dialog state</param>
        /// <param name="customAttributes">may be used to modify controls generated by resonite</param>
        /// <param name="conf">displayed name, secrecy and error output options</param>
        public DialogOptionDefinition(
            object key,
            Action<TDialogState, TValue> setter,
            Func<TDialogState, TValue> getter,
            ICustomAttributeProvider customAttributes,
            DialogOptionAttribute conf)
        {
            this.key = key;
            this.setter = setter ?? throw new ArgumentNullException(nameof(setter));
            this.getter = getter ?? throw new ArgumentNullException(nameof(getter));
            this.customAttributes = customAttributes ?? throw new ArgumentNullException(nameof(customAttributes));
            this.conf = conf ?? throw new ArgumentNullException(nameof(conf));

            if (conf.ToOutsideWorldMapper != null)
            {
                var mapperTypeArgs = conf.ToOutsideWorldMapper.GetGenericArgumentsFromInterface(typeof(IReversibleMapper<,>));
                if (mapperTypeArgs[0] != typeof(TValue))
                {
                    throw new ArgumentException($"Type argument TInner of mapper {conf.ToOutsideWorldMapper} does not match type of value!", nameof(conf));
                }
                if (!conf.HasMapperFor(typeof(TDialogState))) {
                    throw new ArgumentException($"Mapper {conf.ToOutsideWorldMapper} does not have a no-arg or single arg constructor matching {typeof(TDialogState)}!", nameof(conf));
                }
            }
        }

        public DialogOptionDefinition(
            FieldInfo fieldInfo,
            DialogOptionAttribute conf
            ) : this(
                (fieldInfo ?? throw new ArgumentNullException(nameof(fieldInfo))).Name,
                (state, x) => fieldInfo.SetValue(state, x),
                (state) => (TValue)fieldInfo.GetValue(state),
                fieldInfo,
                conf)
        {
            if (fieldInfo.Attributes.HasFlag(FieldAttributes.InitOnly))
            {
                throw new ArgumentException($"Field {fieldInfo.Name} must allow write operations!", nameof(fieldInfo));
            }
        }

        public DialogOptionDefinition(
            PropertyInfo propertyInfo,
            DialogOptionAttribute conf
            ) : this(
                (propertyInfo ?? throw new ArgumentNullException(nameof(propertyInfo))).Name,
                (state, x) => propertyInfo.SetValue(state, x),
                (state) => (TValue)propertyInfo.GetValue(state),
                propertyInfo,
                conf ?? throw new ArgumentNullException(nameof(conf)))
        {
            if (!propertyInfo.CanWrite)
            {
                throw new ArgumentException($"Property {propertyInfo.Name} must allow write operations!", nameof(propertyInfo));
            }
            if (!propertyInfo.CanRead)
            {
                throw new ArgumentException($"Property {propertyInfo.Name} must allow read operations!", nameof(propertyInfo));
            }
        }


        public IDialogElement
            Create(
            UIBuilder uiBuilder,
            TDialogState dialogState,
            Func<(IDictionary<object, string>, IDictionary<object, string>)> onInput,
            bool inUserspace = false)
        {
            if (uiBuilder == null) throw new ArgumentNullException(nameof(uiBuilder));
            if (dialogState == null) throw new ArgumentNullException(nameof(dialogState));
            if (onInput == null) throw new ArgumentNullException(nameof(onInput));

            var slot = uiBuilder.VerticalLayout(spacing: ModInstance.Current.Spacing / 2).Slot;
            IValue<string> errorTextContent;
            Action reset = StaticBuildFunctions.BuildLineWithLabel(conf.Name, uiBuilder, (uiBuilder2) =>
            {
                if (conf.Secret && !inUserspace)
                {
                    //TODO: ensure proper reset functionality
                    var secretDialog = new SecretDialog(this, dialogState, onInput);
                    StaticBuildFunctions.BuildSecretButton(uiBuilder2, () => secretDialog.Open());
                    return secretDialog.Reset;
                }
                else
                {
                    var mapper = conf.CreateMapper(dialogState);
                    if (mapper == null)
                    {
                        return StaticBuildFunctions.BuildEditor(
                            uiBuilder2,
                            uiBuilder2.Root,
                            (x) => { setter(dialogState, x); onInput(); },
                            () => getter(dialogState),
                            conf.Secret,
                            conf.Name,
                            customAttributes
                        );
                    }
                    else
                    {
                        return (Action) typeof(StaticBuildFunctions).GetGenericMethod(
                            nameof(StaticBuildFunctions.BuildEditorWithMapping),
                            BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static,
                            mapper.GetType().GetGenericArgumentsFromInterface(typeof(IReversibleMapper<,>))
                        ).Invoke(null, new object[]{
                            uiBuilder2,
                            uiBuilder2.Root,
                            (Action<TValue>) ((x) => { setter(dialogState, x); onInput(); }),
                            (Func<TValue>)(() => getter(dialogState)),
                            conf.Secret,
                            conf.Name,
                            customAttributes,
                            mapper
                        });
                    }
                }
            });

            if (conf.ShowErrors)
            {
                uiBuilder.PushStyle();
                uiBuilder.Style.PreferredHeight = ModInstance.Current.ErrorHeight;
                uiBuilder.Style.TextColor = colorX.Red;
                var errorText = uiBuilder.Text("", alignment: Alignment.TopRight);
                uiBuilder.PopStyle();
                uiBuilder.NestOut();
                errorTextContent = errorText.Content;
            }
            else
            {
                errorTextContent = null;
            }
            return new Element(key, slot, errorTextContent, reset);
        }

        private class Element : DialogElementBase
        {
            private readonly object _Key;
            private readonly Slot _Slot;
            private readonly IValue<string> _ErrorField;
            private readonly Action _Reset;

            public Element(object key, Slot slot, IValue<string> errorField, Action reset)
            {
                _Key = key;
                _Slot = slot;
                _ErrorField = errorField;
                _Reset = reset;
            }

            public override object Key => _Key;

            public override IEnumerable<object> BoundErrorKeys => new List<object>(new object[] { _Key });

            public override bool Visible
            {
                get => _Slot.ActiveSelf;
                set => _Slot.ActiveSelf = value;
            }
            internal override bool EffectivelyEnabled
            {
                set => _Slot.GetComponentsInChildren<InteractionElement>().ForEach(it => it.Enabled = value);
            }

            public override void DisplayErrors(IDictionary<object, string> allErrors, IDictionary<object, string> unboundErrors)
            {
                if (_ErrorField != null)
                {
                    _ErrorField.Value = allErrors.TryGetValue(_Key, out var error)
                                    ? $"<b>{error}</b>"
                                    : "";
                }
            }

            public override void Reset()
            {
                _Reset();
            }
        }

        /// <summary>
        /// represents a dialog that edits a single value in userspace
        /// </summary>
        private class SecretDialog
        {
            private readonly DialogBuilder<TDialogState> dialogBuilder;
            private readonly string title;
            private readonly TDialogState dialog;
            private Slot slot;

            public SecretDialog(DialogOptionDefinition<TDialogState, TValue> option, TDialogState dialog, Func<(IDictionary<object, string>, IDictionary<object, string>)> onChangeSource)
            {
                //TODO: Dialog binding to IDialogState must be adjusted to cater for popups like this (potential target: condition/config in builder)
                this.dialogBuilder = new DialogBuilder<TDialogState>(addDefaults: false, overrideUpdateAndValidate: (_) => onChangeSource())
                        .AddEntry(option)
                        .AddEntry(new DialogActionDefinition<TDialogState>(
                            null,
                            new DialogActionAttribute(ModInstance.Current.SecretEditorAcceptText, onlyValidating: Array.Empty<object>()),
                            (x) => Close()
                            ));
                this.title = option.conf.Name;
                this.dialog = dialog;
            }

            public void Open()
            {
                Userspace.UserspaceWorld.RunSynchronously(() =>
                {
                    slot?.Destroy();
                    slot = dialogBuilder.BuildWindow(title, Userspace.UserspaceWorld, dialog);
                    var editor = slot.GetComponentInChildren<TextEditor>();
                    editor?.Focus();
                });
            }

            public void Close()
            {
                Userspace.UserspaceWorld.RunSynchronously(() =>
                {
                    slot?.Destroy();
                    slot = null;
                });
            }

            public void Reset()
            {
                UniLog.Warning("TODO: Reset " + this);
            }
        }
    }
}