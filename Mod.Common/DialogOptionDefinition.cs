using FrooxEngine;
using FrooxEngine.UIX;
using System.Reflection;
using System;
using System.Collections.Generic;
using Elements.Core;

namespace UIXDialogBuilder
{
    /// <summary>
    /// Defines a configuration option in the dialog window
    /// </summary>
    /// <typeparam name="TDialogState">type of the dialog object</typeparam>
    /// <typeparam name="TValue">type of the edited value</typeparam>
    public class DialogOptionDefinition<TDialogState, TValue> : IDialogEntryDefinition<TDialogState> where TDialogState : IDialogState
    {
        private readonly object key;
        private readonly Action<TDialogState, TValue> setter;
        private readonly Func<TDialogState, TValue> getter;
        private readonly ICustomAttributeProvider customAttributes;

        private readonly DialogOptionAttribute conf;

        /// <summary>
        /// Creates a configuration option
        /// </summary>
        /// <param name="key">to identify this element</param>
        /// <param name="setter">putting the value into the dialog state</param>
        /// <param name="getter">getting the current value out of the dialog state</param>
        /// <param name="customAttributes">may be used to modify controls generated by resonite</param>
        /// <param name="conf">displayed name, secrecy and error output options</param>
        public DialogOptionDefinition(
            object key,
            Action<TDialogState, TValue> setter,
            Func<TDialogState, TValue> getter,
            ICustomAttributeProvider customAttributes,
            DialogOptionAttribute conf)
        {
            this.key = key;
            this.setter = setter ?? throw new ArgumentNullException(nameof(setter));
            this.getter = getter ?? throw new ArgumentNullException(nameof(getter));
            this.customAttributes = customAttributes ?? throw new ArgumentNullException(nameof(customAttributes));
            this.conf = conf ?? throw new ArgumentNullException(nameof(conf));

            if (conf.ToOutsideWorldMapper != null)
            {
                if (!conf.HasMapperFor(typeof(TDialogState), typeof(TValue)))
                {
                    throw new ArgumentException(
                        conf.ToOutsideWorldMapper.HasConstructorFor(typeof(TDialogState))
                        ? $"{conf.ToOutsideWorldMapper} does not match the type {nameof(IReversibleMapper)}`2[{typeof(TValue)},???]!"
                        : $"{conf.ToOutsideWorldMapper} does not have a no-arg or single arg constructor matching {typeof(TDialogState)}!",
                        nameof(conf)
                    );
                }
            }
            if (conf.EditorGenerator != null)
            {
                if (!conf.HasEditorGeneratorFor(typeof(TDialogState), typeof(TValue)))
                {
                    throw new ArgumentException(
                        conf.EditorGenerator.HasConstructorFor(typeof(TDialogState))
                        ? $"{conf.EditorGenerator} does not match the type {typeof(IEditorGenerator<>).MakeGenericType(conf.ExpectedEditorType(typeof(TValue)))}"
                        : $"{conf.EditorGenerator} does not have a no-arg or single arg constructor matching {typeof(TDialogState)}!",
                        nameof(conf)
                    );
                }
            }
        }

        public DialogOptionDefinition(
            FieldInfo fieldInfo,
            DialogOptionAttribute conf
            ) : this(
                (fieldInfo ?? throw new ArgumentNullException(nameof(fieldInfo))).Name,
                (state, x) => fieldInfo.SetValue(state, x),
                (state) => (TValue)fieldInfo.GetValue(state),
                fieldInfo,
                conf)
        {
            if (fieldInfo.Attributes.HasFlag(FieldAttributes.InitOnly))
            {
                throw new ArgumentException($"Field {fieldInfo.Name} must allow write operations!", nameof(fieldInfo));
            }
        }

        public DialogOptionDefinition(
            PropertyInfo propertyInfo,
            DialogOptionAttribute conf
            ) : this(
                (propertyInfo ?? throw new ArgumentNullException(nameof(propertyInfo))).Name,
                (state, x) => propertyInfo.SetValue(state, x),
                (state) => (TValue)propertyInfo.GetValue(state),
                propertyInfo,
                conf ?? throw new ArgumentNullException(nameof(conf)))
        {
            if (!propertyInfo.CanWrite)
            {
                throw new ArgumentException($"Property {propertyInfo.Name} must allow write operations!", nameof(propertyInfo));
            }
            if (!propertyInfo.CanRead)
            {
                throw new ArgumentException($"Property {propertyInfo.Name} must allow read operations!", nameof(propertyInfo));
            }
        }

        public IDialogElement
            Create(
            UIBuilder uiBuilder,
            TDialogState dialogState,
            Action<object> onInput,
            bool inUserspace = false)
        {
            if (uiBuilder == null) throw new ArgumentNullException(nameof(uiBuilder));
            if (dialogState == null) throw new ArgumentNullException(nameof(dialogState));
            if (onInput == null) throw new ArgumentNullException(nameof(onInput));

            var slot = uiBuilder.VerticalLayout(spacing: ModInstance.Current.Spacing / 2).Slot;
            IValue<string> errorTextContent;
            Action reset;
            Action<IDictionary<object, string>, IDictionary<object, string>> setSecretError;
            (reset, setSecretError) = StaticBuildFunctions.BuildLineWithLabel<(Action, Action<IDictionary<object, string>, IDictionary<object, string>>)>(
                conf.Name, uiBuilder, () =>
            {
                if (conf.Secret && !inUserspace)
                {
                    var secretDialog = new SecretDialog(conf.Name, this, dialogState, onInput);
                    StaticBuildFunctions.BuildSecretButton(uiBuilder, () => secretDialog.Open());
                    return (secretDialog.Reset, secretDialog.DisplayError);
                }
                else
                {
                    var mapper = conf.CreateMapper(dialogState);
                    if (mapper == null)
                    {
                        return (StaticBuildFunctions.BuildEditor(
                            uiBuilder,
                            uiBuilder.Root,
                            (x) => { setter(dialogState, x); onInput(key); },
                            () => getter(dialogState),
                            conf.Secret,
                            conf.Name,
                            customAttributes,
                            (IEditorGenerator<TValue>)(conf.EditorGenerator?.Construct(dialogState))
                        ), null);
                    }
                    else
                    {
                        return ((Action)typeof(StaticBuildFunctions).GetGenericMethod(
                            nameof(StaticBuildFunctions.BuildEditorWithMapping),
                            BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static,
                            mapper.GetType().GetGenericArgumentsFromInterface(typeof(IReversibleMapper<,>))
                        ).Invoke(null, new object[]{
                            uiBuilder,
                            uiBuilder.Root,
                            (Action<TValue>)((x) => { setter(dialogState, x); onInput(key); }),
                            (Func<TValue>)(() => getter(dialogState)),
                            conf.Secret,
                            conf.Name,
                            customAttributes,
                            mapper,
                            conf.EditorGenerator?.Construct(dialogState)
                        }), null);
                    }
                }
            });

            if (conf.ShowErrors)
            {
                uiBuilder.PushStyle();
                uiBuilder.Style.PreferredHeight = ModInstance.Current.ErrorHeight;
                uiBuilder.Style.TextColor = colorX.Red;

                var errorText = uiBuilder.Text("", alignment: Alignment.TopRight);
                uiBuilder.PopStyle();
                uiBuilder.NestOut();
                errorTextContent = errorText.Content;
            }
            else
            {
                errorTextContent = null;
            }
            return new Element(key, slot, (allErrors, unbound) =>
            {
                setSecretError?.Invoke(allErrors, unbound);
                if (errorTextContent != null)
                {
                    errorTextContent.Value = allErrors.TryGetValue(key, out var error)
                                    ? $"<b>{error}</b>"
                                    : "";
                }
            }, reset);
        }

        private class Element : DialogElementBase
        {
            private readonly object _Key;
            private readonly Slot _Slot;
            private readonly Action<IDictionary<object, string>, IDictionary<object, string>> _DisplayErrors;
            private readonly Action _Reset;

            public Element(object key, Slot slot, Action<IDictionary<object, string>, IDictionary<object, string>> displayErrors, Action reset)
            {
                _Key = key;
                _Slot = slot;
                _DisplayErrors = displayErrors;
                _Reset = reset;
            }

            public override object Key => _Key;

            public override IEnumerable<object> BoundErrorKeys => new List<object>(new object[] { _Key });

            public override bool Visible
            {
                get => _Slot.ActiveSelf;
                set => _Slot.ActiveSelf = value;
            }
            internal override bool EffectivelyEnabled
            {
                set => _Slot.GetComponentsInChildren<InteractionElement>().ForEach(it => it.Enabled = value);
            }

            public override void DisplayErrors(IDictionary<object, string> allErrors, IDictionary<object, string> unboundErrors)
            {
                _DisplayErrors?.Invoke(allErrors, unboundErrors);
            }

            public override void Reset()
            {
                _Reset();
            }
        }

        /// <summary>
        /// represents a dialog that edits a single value in userspace
        /// </summary>
        private class SecretDialog
        {
            private readonly DialogBuilder<TDialogState> dialogBuilder;
            private readonly string title;
            private readonly TDialogState dialogState;
            private Slot slot;
            private Dialog dialog;

            public SecretDialog(string title, IDialogEntryDefinition<TDialogState> option, TDialogState dialogState, Action<object> onInput)
            {
                dialogBuilder = new DialogBuilder<TDialogState>(addDefaults: false, onInput)
                        .AddEntry(option)
                        .AddEntry(new DialogActionDefinition<TDialogState>(
                            null,
                            new DialogActionAttribute(ModInstance.Current.SecretEditorAcceptText, onlyValidating: Array.Empty<object>()),
                            (x, u) => Close()
                            ));
                this.title = title;
                this.dialogState = dialogState;
            }

            public void Open()
            {
                Userspace.UserspaceWorld.RunSynchronously(() =>
                {
                    slot?.Destroy();
                    (dialog, slot) = dialogBuilder.BuildWindow(title, Userspace.UserspaceWorld, dialogState, dialogState.Dialog);
                    var editor = slot.GetComponentInChildren<TextEditor>();
                    editor?.Focus();
                });
            }

            public void Close()
            {
                Userspace.UserspaceWorld.RunSynchronously(() =>
                {
                    slot?.Destroy();
                    slot = null;
                    dialog = null;
                });
            }

            public void Reset()
            {
                Userspace.UserspaceWorld.RunSynchronously(() =>
                {
                    dialog?.Reset();
                });
            }

            internal void DisplayError(IDictionary<object, string> allErrors, IDictionary<object, string> unboundErrors)
            {
                Userspace.UserspaceWorld.RunSynchronously(() =>
                {
                    dialog?.DisplayErrors(allErrors, unboundErrors);
                });
            }
        }
    }
}